<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>src.tools.phpfina API documentation</title>
<meta name="description" content="tools to manage (open/create) PHPFina feeds â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.tools.phpfina</code></h1>
</header>
<section id="section-intro">
<p>tools to manage (open/create) PHPFina feeds</p>
<p>Fina = Fixed Interval No Averaging</p>
<p>this small library uses seek</p>
<p>Seek can be called one of two ways:</p>
<p>x.seek(offset)</p>
<p>x.seek(offset, starting_point)</p>
<p>starting_point can be 0, 1, or 2</p>
<p>0 - Default. Offset relative to beginning of file</p>
<p>1 - Start from the current position in the file</p>
<p>2 - Start from the end of a file (will require a negative offset)</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
tools to manage (open/create) PHPFina feeds

Fina = Fixed Interval No Averaging

this small library uses seek

Seek can be called one of two ways:

x.seek(offset)

x.seek(offset, starting_point)

starting_point can be 0, 1, or 2

 0 - Default. Offset relative to beginning of file

 1 - Start from the current position in the file

 2 - Start from the end of a file (will require a negative offset)
&#34;&#34;&#34;

from datetime import datetime
import math
import struct
import numpy as np
import os.path

# if want to work on the active directory, just use dir=&#34;.&#34;
dir=&#34;phpfina&#34;

# convert a unix time stamp to a UTC expression
def humanDate(uts):
    human=datetime.utcfromtimestamp(uts).strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)
    return human

# is this really needed or would we go for struct.unpack all the time ?
def readBytes(nb,file):
    bytes = file.read(4)
    value=int.from_bytes(bytes, byteorder=&#39;little&#39;, signed=False)
    return value

# for debugging in case
def checkPoints(nb,position,interval):
    with open(&#34;{}/{}.dat&#34;.format(dir,nb), &#34;rb&#34;) as ts:
        for i in range(300):
            nbPtInHour=60*60/interval
            offset=int((position+i)*4)
            print(offset)
            ts.seek(offset, 0)
            hexa = ts.read(4)
            aa= bytearray(hexa)
            value=struct.unpack(&#39;&lt;f&#39;, aa)[0]
            print(value)

&#34;&#34;&#34;
a bunch of functions to create a synthetic PHPFina feed from a list or a numpy vector
&#34;&#34;&#34;
def createMeta(nb,start,step,dir=dir):
    &#34;&#34;&#34;
    create meta given :

    - a feed number

    - a unixtimestamp as start

    - a step
    &#34;&#34;&#34;
    f=open(&#34;{}/{}.meta&#34;.format(dir,nb),&#34;wb&#34;)
    data=np.array([0,0,step,start])
    format=&#39;&lt;&#39;+&#39;I&#39;*len(data)
    bin=struct.pack(format,*data)
    f.write(bin)
    f.close()

def createFeed(nb,data,dir=dir):
    &#34;&#34;&#34;
    create a dat file given :

    - a feed number

    - a numpy vector of data
    &#34;&#34;&#34;
    f=open(&#34;{}/{}.dat&#34;.format(dir,nb),&#34;wb&#34;)
    format=&#39;&lt;&#39;+&#39;f&#39;*len(data)
    bin=struct.pack(format,*data)
    f.write(bin)
    f.close()

def getMetas(nb,dir=dir):
    &#34;&#34;&#34;
    read meta given a feed number
    
    print (interval,starting timestamp)
    &#34;&#34;&#34;
    f=open(&#34;{}/{}.meta&#34;.format(dir,nb),&#34;rb&#34;)
    f.seek(8,0)
    hexa = f.read(8)
    aa= bytearray(hexa)
    if len(aa)==8:
      decoded=struct.unpack(&#39;&lt;2I&#39;, aa)
    print(decoded)
    f.close()

def newPHPFina(nb,start,step,data,dir=dir):
    &#34;&#34;&#34;
    create a PHPFina object, without any reference to any EmonCMS server

    start : unix time stamp of the starting point

    step : timestep/interval in s

    data : data to be injected as a numpy vector
    &#34;&#34;&#34;
    meta=&#34;{}/{}.meta&#34;.format(dir,nb)
    if os.path.isfile(meta) and os.path.getsize(meta) != 0:
        print(&#34;meta file exists&#34;)
        getMetas(nb,dir)
    else:
        print(&#34;creating meta&#34;)
        createMeta(nb,start,step,dir)
    if os.path.isfile(&#34;{}/{}.dat&#34;.format(dir,nb)):
        print(&#34;data file exists&#34;)
    else:
        print(&#34;creating data file&#34;)
        createFeed(nb,data,dir)


&#34;&#34;&#34;
import and manage emoncms PHPFINA objects
&#34;&#34;&#34;
class PHPFina:
    def __init__(self,nb,step,dir=dir):
        &#34;&#34;&#34;
        nb : feed number

        step : the period in second at which you sample from the timeseries
        &#34;&#34;&#34;
        #starttime and interval expressed in seconds
        #starttime is a unixtimestamp
        self._startTime = 0
        self._interval = 0
        self._nb = nb
        # the unixtimestamp in seconds at which you decide to start sampling
        self._SamplingPos = 0
        self._step = step
        self._dir = dir
        self._datas = []

    def getMetas(self):
        &#34;&#34;&#34;
        gets the metas from the meta file and stores them

        unix timestamp of the feed&#39;s first point (_startTime)

        interval in s (_interval)
        &#34;&#34;&#34;
        with open(&#34;{}/{}.meta&#34;.format(self._dir,self._nb), &#34;rb&#34;) as metas:
            # Seek a specific position in the file and read N bytes
            metas.seek(8, 0)
            interval=readBytes(4,metas)
            metas.seek(12, 0)
            startTime=readBytes(4,metas)
            #print(&#34;startTime {} UTC / {}&#34;.format(humanDate(startTime),startTime))
            #print(&#34;interval {}s&#34;.format(interval))
            self._startTime=startTime
            self._interval=interval

    def setStart(self,unixTimeStart):
        &#34;&#34;&#34;
        set the sampling starting point given a unix time stamp (_SamplingPos)
        &#34;&#34;&#34;
        self._SamplingPos=int((unixTimeStart-self._startTime)/self._interval)
        #print(&#34;Timeserie {} sampling will start on record number {}&#34;.format(self._nb,self._SamplingPos))

    def getDatas(self,nbSteps):
        &#34;&#34;&#34;
        stores an array of values extracted from the timeserie

        nbSteps datas are sampled from _SamplingPos at a period equal to _step

        a PHPFina file is made of 4 bytes float values, with NAN when nothing was recorded from the sensor
        &#34;&#34;&#34;
        start = self._SamplingPos
        nbPtInStep=self._step//self._interval
        if self._step/self._interval - nbPtInStep == 0:
            offset=0
        elif self._step/self._interval - nbPtInStep == 0.5:
            print(&#34;we have an half step offset&#34;)
            offset=1
        else:
            print(&#34;offset - we cannot get the datas - check steps/intervals&#34;)
            return
        position=int(start*4)
        with open(&#34;{}/{}.dat&#34;.format(self._dir,self._nb), &#34;rb&#34;) as ts:
            for i in range(nbSteps):
                ts.seek(position, 0)
                hexa = ts.read(4)
                aa= bytearray(hexa)
                if len(aa)==4:
                  value=struct.unpack(&#39;&lt;f&#39;, aa)[0]
                else:
                  print(&#34;unpacking problem {} len is {} position is {}&#34;.format(i,len(aa),position))
                if math.isnan(value):
                    #print(&#34;timeseries {} - there is a NAN at position {} in the timeserie or point number {}&#34;.format(self._nb,position,i))
                    j=1
                    while True:
                        ramble=position+j*4
                        ts.seek(ramble, 0)
                        hexa = ts.read(4)
                        aa= bytearray(hexa)
                        value=struct.unpack(&#39;&lt;f&#39;, aa)[0]
                        if math.isnan(value):
                            j+=1
                        else:
                            break
                    #print(&#34;we found a value {} {}s after the NAN&#34;.format(value,self._interval*j))
                #print(position)
                #print(value)
                #input(&#34;press key&#34;)
                self._datas.append(value)
                if (i % 2) == 0:
                    position+=nbPtInStep*4
                else:
                    position+=(nbPtInStep+offset)*4

    def getKwh(self,nbSteps):
        &#34;&#34;&#34;
        only for &#34;energy&#34; timeseries

        accumulates the power for each step and outputs the energy consumption in Kwh within the step to come
        &#34;&#34;&#34;
        start = self._SamplingPos
        nbPtInStep=self._step//self._interval
        #print(&#34;an hour is sectionned in {} parts&#34;.format(nbPtInStep))
        with open(&#34;{}/{}.dat&#34;.format(self._dir,self._nb), &#34;rb&#34;) as ts:
            for i in range(nbSteps+1):
                position=int((start+i*nbPtInStep)*4)
                acc=0
                ts.seek(position, 0)
                hexa = ts.read(4*nbPtInStep)
                aa= bytearray(hexa)
                if len(aa)==4*nbPtInStep:
                    values=struct.unpack(&#39;&lt;{}f&#39;.format(nbPtInStep), aa)
                for j in range(len(values)):
                    if math.isnan(values[j]):
                        val=0
                    else:
                        val=values[j]
                    acc+=val*self._interval
                if math.isnan(acc):
                    acc=0
                    print(&#34;BUG : consumption for full step is NAN !&#34;)
                # kwh conversion !!
                self._datas.append(0.001*acc/3600)

    def unAcc(self):
        &#34;&#34;&#34;
        EmonCMS can provide the accumulated kwh feed over the whole recording period, like an energy meter.

        from the accumulated kwh feed, the kwh consumed per hour can be recalculated

        NOTA NOTA NOTA : recalculating from the instantaneous power is a better option

        Indeed, there may be missing data in feeds dedicated to the accumulation of Kwh.

        Experience shows that only instant power feeds ARE MANUALLY corrected in real time during monitoring.
        &#34;&#34;&#34;
        unAccvalues=[]
        for i in range(len(self._datas)-1):
            if self._datas[i+1]-self._datas[i] &lt;0:
                print(&#34;bug&#34;)
                print(i)
                print(&#34;values are {} and {}&#34;.format(self._datas[i+1],self._datas[i]))
            unAccvalues.append(self._datas[i+1]-self._datas[i])
        self._datas=unAccvalues</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.tools.phpfina.checkPoints"><code class="name flex">
<span>def <span class="ident">checkPoints</span></span>(<span>nb, position, interval)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkPoints(nb,position,interval):
    with open(&#34;{}/{}.dat&#34;.format(dir,nb), &#34;rb&#34;) as ts:
        for i in range(300):
            nbPtInHour=60*60/interval
            offset=int((position+i)*4)
            print(offset)
            ts.seek(offset, 0)
            hexa = ts.read(4)
            aa= bytearray(hexa)
            value=struct.unpack(&#39;&lt;f&#39;, aa)[0]
            print(value)</code></pre>
</details>
</dd>
<dt id="src.tools.phpfina.createFeed"><code class="name flex">
<span>def <span class="ident">createFeed</span></span>(<span>nb, data, dir='phpfina')</span>
</code></dt>
<dd>
<div class="desc"><p>create a dat file given :</p>
<ul>
<li>
<p>a feed number</p>
</li>
<li>
<p>a numpy vector of data</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createFeed(nb,data,dir=dir):
    &#34;&#34;&#34;
    create a dat file given :

    - a feed number

    - a numpy vector of data
    &#34;&#34;&#34;
    f=open(&#34;{}/{}.dat&#34;.format(dir,nb),&#34;wb&#34;)
    format=&#39;&lt;&#39;+&#39;f&#39;*len(data)
    bin=struct.pack(format,*data)
    f.write(bin)
    f.close()</code></pre>
</details>
</dd>
<dt id="src.tools.phpfina.createMeta"><code class="name flex">
<span>def <span class="ident">createMeta</span></span>(<span>nb, start, step, dir='phpfina')</span>
</code></dt>
<dd>
<div class="desc"><p>create meta given :</p>
<ul>
<li>
<p>a feed number</p>
</li>
<li>
<p>a unixtimestamp as start</p>
</li>
<li>
<p>a step</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createMeta(nb,start,step,dir=dir):
    &#34;&#34;&#34;
    create meta given :

    - a feed number

    - a unixtimestamp as start

    - a step
    &#34;&#34;&#34;
    f=open(&#34;{}/{}.meta&#34;.format(dir,nb),&#34;wb&#34;)
    data=np.array([0,0,step,start])
    format=&#39;&lt;&#39;+&#39;I&#39;*len(data)
    bin=struct.pack(format,*data)
    f.write(bin)
    f.close()</code></pre>
</details>
</dd>
<dt id="src.tools.phpfina.getMetas"><code class="name flex">
<span>def <span class="ident">getMetas</span></span>(<span>nb, dir='phpfina')</span>
</code></dt>
<dd>
<div class="desc"><p>read meta given a feed number</p>
<p>print (interval,starting timestamp)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMetas(nb,dir=dir):
    &#34;&#34;&#34;
    read meta given a feed number
    
    print (interval,starting timestamp)
    &#34;&#34;&#34;
    f=open(&#34;{}/{}.meta&#34;.format(dir,nb),&#34;rb&#34;)
    f.seek(8,0)
    hexa = f.read(8)
    aa= bytearray(hexa)
    if len(aa)==8:
      decoded=struct.unpack(&#39;&lt;2I&#39;, aa)
    print(decoded)
    f.close()</code></pre>
</details>
</dd>
<dt id="src.tools.phpfina.humanDate"><code class="name flex">
<span>def <span class="ident">humanDate</span></span>(<span>uts)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def humanDate(uts):
    human=datetime.utcfromtimestamp(uts).strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)
    return human</code></pre>
</details>
</dd>
<dt id="src.tools.phpfina.newPHPFina"><code class="name flex">
<span>def <span class="ident">newPHPFina</span></span>(<span>nb, start, step, data, dir='phpfina')</span>
</code></dt>
<dd>
<div class="desc"><p>create a PHPFina object, without any reference to any EmonCMS server</p>
<p>start : unix time stamp of the starting point</p>
<p>step : timestep/interval in s</p>
<p>data : data to be injected as a numpy vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newPHPFina(nb,start,step,data,dir=dir):
    &#34;&#34;&#34;
    create a PHPFina object, without any reference to any EmonCMS server

    start : unix time stamp of the starting point

    step : timestep/interval in s

    data : data to be injected as a numpy vector
    &#34;&#34;&#34;
    meta=&#34;{}/{}.meta&#34;.format(dir,nb)
    if os.path.isfile(meta) and os.path.getsize(meta) != 0:
        print(&#34;meta file exists&#34;)
        getMetas(nb,dir)
    else:
        print(&#34;creating meta&#34;)
        createMeta(nb,start,step,dir)
    if os.path.isfile(&#34;{}/{}.dat&#34;.format(dir,nb)):
        print(&#34;data file exists&#34;)
    else:
        print(&#34;creating data file&#34;)
        createFeed(nb,data,dir)</code></pre>
</details>
</dd>
<dt id="src.tools.phpfina.readBytes"><code class="name flex">
<span>def <span class="ident">readBytes</span></span>(<span>nb, file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readBytes(nb,file):
    bytes = file.read(4)
    value=int.from_bytes(bytes, byteorder=&#39;little&#39;, signed=False)
    return value</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.tools.phpfina.PHPFina"><code class="flex name class">
<span>class <span class="ident">PHPFina</span></span>
<span>(</span><span>nb, step, dir='phpfina')</span>
</code></dt>
<dd>
<div class="desc"><p>nb : feed number</p>
<p>step : the period in second at which you sample from the timeseries</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PHPFina:
    def __init__(self,nb,step,dir=dir):
        &#34;&#34;&#34;
        nb : feed number

        step : the period in second at which you sample from the timeseries
        &#34;&#34;&#34;
        #starttime and interval expressed in seconds
        #starttime is a unixtimestamp
        self._startTime = 0
        self._interval = 0
        self._nb = nb
        # the unixtimestamp in seconds at which you decide to start sampling
        self._SamplingPos = 0
        self._step = step
        self._dir = dir
        self._datas = []

    def getMetas(self):
        &#34;&#34;&#34;
        gets the metas from the meta file and stores them

        unix timestamp of the feed&#39;s first point (_startTime)

        interval in s (_interval)
        &#34;&#34;&#34;
        with open(&#34;{}/{}.meta&#34;.format(self._dir,self._nb), &#34;rb&#34;) as metas:
            # Seek a specific position in the file and read N bytes
            metas.seek(8, 0)
            interval=readBytes(4,metas)
            metas.seek(12, 0)
            startTime=readBytes(4,metas)
            #print(&#34;startTime {} UTC / {}&#34;.format(humanDate(startTime),startTime))
            #print(&#34;interval {}s&#34;.format(interval))
            self._startTime=startTime
            self._interval=interval

    def setStart(self,unixTimeStart):
        &#34;&#34;&#34;
        set the sampling starting point given a unix time stamp (_SamplingPos)
        &#34;&#34;&#34;
        self._SamplingPos=int((unixTimeStart-self._startTime)/self._interval)
        #print(&#34;Timeserie {} sampling will start on record number {}&#34;.format(self._nb,self._SamplingPos))

    def getDatas(self,nbSteps):
        &#34;&#34;&#34;
        stores an array of values extracted from the timeserie

        nbSteps datas are sampled from _SamplingPos at a period equal to _step

        a PHPFina file is made of 4 bytes float values, with NAN when nothing was recorded from the sensor
        &#34;&#34;&#34;
        start = self._SamplingPos
        nbPtInStep=self._step//self._interval
        if self._step/self._interval - nbPtInStep == 0:
            offset=0
        elif self._step/self._interval - nbPtInStep == 0.5:
            print(&#34;we have an half step offset&#34;)
            offset=1
        else:
            print(&#34;offset - we cannot get the datas - check steps/intervals&#34;)
            return
        position=int(start*4)
        with open(&#34;{}/{}.dat&#34;.format(self._dir,self._nb), &#34;rb&#34;) as ts:
            for i in range(nbSteps):
                ts.seek(position, 0)
                hexa = ts.read(4)
                aa= bytearray(hexa)
                if len(aa)==4:
                  value=struct.unpack(&#39;&lt;f&#39;, aa)[0]
                else:
                  print(&#34;unpacking problem {} len is {} position is {}&#34;.format(i,len(aa),position))
                if math.isnan(value):
                    #print(&#34;timeseries {} - there is a NAN at position {} in the timeserie or point number {}&#34;.format(self._nb,position,i))
                    j=1
                    while True:
                        ramble=position+j*4
                        ts.seek(ramble, 0)
                        hexa = ts.read(4)
                        aa= bytearray(hexa)
                        value=struct.unpack(&#39;&lt;f&#39;, aa)[0]
                        if math.isnan(value):
                            j+=1
                        else:
                            break
                    #print(&#34;we found a value {} {}s after the NAN&#34;.format(value,self._interval*j))
                #print(position)
                #print(value)
                #input(&#34;press key&#34;)
                self._datas.append(value)
                if (i % 2) == 0:
                    position+=nbPtInStep*4
                else:
                    position+=(nbPtInStep+offset)*4

    def getKwh(self,nbSteps):
        &#34;&#34;&#34;
        only for &#34;energy&#34; timeseries

        accumulates the power for each step and outputs the energy consumption in Kwh within the step to come
        &#34;&#34;&#34;
        start = self._SamplingPos
        nbPtInStep=self._step//self._interval
        #print(&#34;an hour is sectionned in {} parts&#34;.format(nbPtInStep))
        with open(&#34;{}/{}.dat&#34;.format(self._dir,self._nb), &#34;rb&#34;) as ts:
            for i in range(nbSteps+1):
                position=int((start+i*nbPtInStep)*4)
                acc=0
                ts.seek(position, 0)
                hexa = ts.read(4*nbPtInStep)
                aa= bytearray(hexa)
                if len(aa)==4*nbPtInStep:
                    values=struct.unpack(&#39;&lt;{}f&#39;.format(nbPtInStep), aa)
                for j in range(len(values)):
                    if math.isnan(values[j]):
                        val=0
                    else:
                        val=values[j]
                    acc+=val*self._interval
                if math.isnan(acc):
                    acc=0
                    print(&#34;BUG : consumption for full step is NAN !&#34;)
                # kwh conversion !!
                self._datas.append(0.001*acc/3600)

    def unAcc(self):
        &#34;&#34;&#34;
        EmonCMS can provide the accumulated kwh feed over the whole recording period, like an energy meter.

        from the accumulated kwh feed, the kwh consumed per hour can be recalculated

        NOTA NOTA NOTA : recalculating from the instantaneous power is a better option

        Indeed, there may be missing data in feeds dedicated to the accumulation of Kwh.

        Experience shows that only instant power feeds ARE MANUALLY corrected in real time during monitoring.
        &#34;&#34;&#34;
        unAccvalues=[]
        for i in range(len(self._datas)-1):
            if self._datas[i+1]-self._datas[i] &lt;0:
                print(&#34;bug&#34;)
                print(i)
                print(&#34;values are {} and {}&#34;.format(self._datas[i+1],self._datas[i]))
            unAccvalues.append(self._datas[i+1]-self._datas[i])
        self._datas=unAccvalues</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.tools.phpfina.PHPFina.getDatas"><code class="name flex">
<span>def <span class="ident">getDatas</span></span>(<span>self, nbSteps)</span>
</code></dt>
<dd>
<div class="desc"><p>stores an array of values extracted from the timeserie</p>
<p>nbSteps datas are sampled from _SamplingPos at a period equal to _step</p>
<p>a PHPFina file is made of 4 bytes float values, with NAN when nothing was recorded from the sensor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDatas(self,nbSteps):
    &#34;&#34;&#34;
    stores an array of values extracted from the timeserie

    nbSteps datas are sampled from _SamplingPos at a period equal to _step

    a PHPFina file is made of 4 bytes float values, with NAN when nothing was recorded from the sensor
    &#34;&#34;&#34;
    start = self._SamplingPos
    nbPtInStep=self._step//self._interval
    if self._step/self._interval - nbPtInStep == 0:
        offset=0
    elif self._step/self._interval - nbPtInStep == 0.5:
        print(&#34;we have an half step offset&#34;)
        offset=1
    else:
        print(&#34;offset - we cannot get the datas - check steps/intervals&#34;)
        return
    position=int(start*4)
    with open(&#34;{}/{}.dat&#34;.format(self._dir,self._nb), &#34;rb&#34;) as ts:
        for i in range(nbSteps):
            ts.seek(position, 0)
            hexa = ts.read(4)
            aa= bytearray(hexa)
            if len(aa)==4:
              value=struct.unpack(&#39;&lt;f&#39;, aa)[0]
            else:
              print(&#34;unpacking problem {} len is {} position is {}&#34;.format(i,len(aa),position))
            if math.isnan(value):
                #print(&#34;timeseries {} - there is a NAN at position {} in the timeserie or point number {}&#34;.format(self._nb,position,i))
                j=1
                while True:
                    ramble=position+j*4
                    ts.seek(ramble, 0)
                    hexa = ts.read(4)
                    aa= bytearray(hexa)
                    value=struct.unpack(&#39;&lt;f&#39;, aa)[0]
                    if math.isnan(value):
                        j+=1
                    else:
                        break
                #print(&#34;we found a value {} {}s after the NAN&#34;.format(value,self._interval*j))
            #print(position)
            #print(value)
            #input(&#34;press key&#34;)
            self._datas.append(value)
            if (i % 2) == 0:
                position+=nbPtInStep*4
            else:
                position+=(nbPtInStep+offset)*4</code></pre>
</details>
</dd>
<dt id="src.tools.phpfina.PHPFina.getKwh"><code class="name flex">
<span>def <span class="ident">getKwh</span></span>(<span>self, nbSteps)</span>
</code></dt>
<dd>
<div class="desc"><p>only for "energy" timeseries</p>
<p>accumulates the power for each step and outputs the energy consumption in Kwh within the step to come</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getKwh(self,nbSteps):
    &#34;&#34;&#34;
    only for &#34;energy&#34; timeseries

    accumulates the power for each step and outputs the energy consumption in Kwh within the step to come
    &#34;&#34;&#34;
    start = self._SamplingPos
    nbPtInStep=self._step//self._interval
    #print(&#34;an hour is sectionned in {} parts&#34;.format(nbPtInStep))
    with open(&#34;{}/{}.dat&#34;.format(self._dir,self._nb), &#34;rb&#34;) as ts:
        for i in range(nbSteps+1):
            position=int((start+i*nbPtInStep)*4)
            acc=0
            ts.seek(position, 0)
            hexa = ts.read(4*nbPtInStep)
            aa= bytearray(hexa)
            if len(aa)==4*nbPtInStep:
                values=struct.unpack(&#39;&lt;{}f&#39;.format(nbPtInStep), aa)
            for j in range(len(values)):
                if math.isnan(values[j]):
                    val=0
                else:
                    val=values[j]
                acc+=val*self._interval
            if math.isnan(acc):
                acc=0
                print(&#34;BUG : consumption for full step is NAN !&#34;)
            # kwh conversion !!
            self._datas.append(0.001*acc/3600)</code></pre>
</details>
</dd>
<dt id="src.tools.phpfina.PHPFina.getMetas"><code class="name flex">
<span>def <span class="ident">getMetas</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>gets the metas from the meta file and stores them</p>
<p>unix timestamp of the feed's first point (_startTime)</p>
<p>interval in s (_interval)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMetas(self):
    &#34;&#34;&#34;
    gets the metas from the meta file and stores them

    unix timestamp of the feed&#39;s first point (_startTime)

    interval in s (_interval)
    &#34;&#34;&#34;
    with open(&#34;{}/{}.meta&#34;.format(self._dir,self._nb), &#34;rb&#34;) as metas:
        # Seek a specific position in the file and read N bytes
        metas.seek(8, 0)
        interval=readBytes(4,metas)
        metas.seek(12, 0)
        startTime=readBytes(4,metas)
        #print(&#34;startTime {} UTC / {}&#34;.format(humanDate(startTime),startTime))
        #print(&#34;interval {}s&#34;.format(interval))
        self._startTime=startTime
        self._interval=interval</code></pre>
</details>
</dd>
<dt id="src.tools.phpfina.PHPFina.setStart"><code class="name flex">
<span>def <span class="ident">setStart</span></span>(<span>self, unixTimeStart)</span>
</code></dt>
<dd>
<div class="desc"><p>set the sampling starting point given a unix time stamp (_SamplingPos)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setStart(self,unixTimeStart):
    &#34;&#34;&#34;
    set the sampling starting point given a unix time stamp (_SamplingPos)
    &#34;&#34;&#34;
    self._SamplingPos=int((unixTimeStart-self._startTime)/self._interval)</code></pre>
</details>
</dd>
<dt id="src.tools.phpfina.PHPFina.unAcc"><code class="name flex">
<span>def <span class="ident">unAcc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>EmonCMS can provide the accumulated kwh feed over the whole recording period, like an energy meter.</p>
<p>from the accumulated kwh feed, the kwh consumed per hour can be recalculated</p>
<p>NOTA NOTA NOTA : recalculating from the instantaneous power is a better option</p>
<p>Indeed, there may be missing data in feeds dedicated to the accumulation of Kwh.</p>
<p>Experience shows that only instant power feeds ARE MANUALLY corrected in real time during monitoring.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unAcc(self):
    &#34;&#34;&#34;
    EmonCMS can provide the accumulated kwh feed over the whole recording period, like an energy meter.

    from the accumulated kwh feed, the kwh consumed per hour can be recalculated

    NOTA NOTA NOTA : recalculating from the instantaneous power is a better option

    Indeed, there may be missing data in feeds dedicated to the accumulation of Kwh.

    Experience shows that only instant power feeds ARE MANUALLY corrected in real time during monitoring.
    &#34;&#34;&#34;
    unAccvalues=[]
    for i in range(len(self._datas)-1):
        if self._datas[i+1]-self._datas[i] &lt;0:
            print(&#34;bug&#34;)
            print(i)
            print(&#34;values are {} and {}&#34;.format(self._datas[i+1],self._datas[i]))
        unAccvalues.append(self._datas[i+1]-self._datas[i])
    self._datas=unAccvalues</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.tools" href="index.html">src.tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="src.tools.phpfina.checkPoints" href="#src.tools.phpfina.checkPoints">checkPoints</a></code></li>
<li><code><a title="src.tools.phpfina.createFeed" href="#src.tools.phpfina.createFeed">createFeed</a></code></li>
<li><code><a title="src.tools.phpfina.createMeta" href="#src.tools.phpfina.createMeta">createMeta</a></code></li>
<li><code><a title="src.tools.phpfina.getMetas" href="#src.tools.phpfina.getMetas">getMetas</a></code></li>
<li><code><a title="src.tools.phpfina.humanDate" href="#src.tools.phpfina.humanDate">humanDate</a></code></li>
<li><code><a title="src.tools.phpfina.newPHPFina" href="#src.tools.phpfina.newPHPFina">newPHPFina</a></code></li>
<li><code><a title="src.tools.phpfina.readBytes" href="#src.tools.phpfina.readBytes">readBytes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.tools.phpfina.PHPFina" href="#src.tools.phpfina.PHPFina">PHPFina</a></code></h4>
<ul class="">
<li><code><a title="src.tools.phpfina.PHPFina.getDatas" href="#src.tools.phpfina.PHPFina.getDatas">getDatas</a></code></li>
<li><code><a title="src.tools.phpfina.PHPFina.getKwh" href="#src.tools.phpfina.PHPFina.getKwh">getKwh</a></code></li>
<li><code><a title="src.tools.phpfina.PHPFina.getMetas" href="#src.tools.phpfina.PHPFina.getMetas">getMetas</a></code></li>
<li><code><a title="src.tools.phpfina.PHPFina.setStart" href="#src.tools.phpfina.PHPFina.setStart">setStart</a></code></li>
<li><code><a title="src.tools.phpfina.PHPFina.unAcc" href="#src.tools.phpfina.PHPFina.unAcc">unAcc</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>